from telegram import Update
from telegram.ext import CallbackContext
import database as db
import smart_reminder
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

async def remind(update: Update, context: CallbackContext):
    user_id = update.effective_user.id
    if not context.args:
        reminders = db.get_active_reminders(user_id)
        if not reminders:
            await update.message.reply_text("‚è∞ –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π")
            return
        msg = "‚è∞ **–ê–∫—Ç–∏–≤–Ω—ã–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è:**\n"
        for rid, interval, next_tr in reminders:
            msg += f"  ID {rid}: –∫–∞–∂–¥—ã–µ {interval} –º–∏–Ω (—Å–ª–µ–¥. ~{next_tr[11:16]})\n"
        msg += "\n–û—Ç–º–µ–Ω–∏—Ç—å: /remind_cancel <id>"
        await update.message.reply_text(msg, parse_mode='Markdown')
        return
    try:
        minutes = int(context.args[0])
        if minutes <= 0:
            raise ValueError
    except ValueError:
        await update.message.reply_text("‚ùå –£–∫–∞–∂–∏—Ç–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ –º–∏–Ω—É—Ç")
        return
    rid = db.add_reminder(user_id, minutes)
    context.job_queue.run_repeating(
        reminder_callback,
        interval=minutes*60,
        first=minutes*60,
        data=(user_id, rid),
        name=f"remind_{rid}"
    )
    await update.message.reply_text(f"‚è∞ –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ #{rid} —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –∫–∞–∂–¥—ã–µ {minutes} –º–∏–Ω")

async def remind_cancel(update: Update, context: CallbackContext):
    user_id = update.effective_user.id
    if not context.args:
        await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /remind_cancel <id>")
        return
    try:
        rid = int(context.args[0])
    except ValueError:
        await update.message.reply_text("‚ùå –£–∫–∞–∂–∏—Ç–µ —á–∏—Å–ª–æ–≤–æ–π ID")
        return
    db.deactivate_reminder(rid, user_id)
    jobs = context.job_queue.get_jobs_by_name(f"remind_{rid}")
    for job in jobs:
        job.schedule_removal()
    await update.message.reply_text(f"‚úÖ –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ #{rid} –æ—Ç–º–µ–Ω–µ–Ω–æ")

async def reminder_callback(context: CallbackContext):
    job = context.job
    user_id, rid = job.data
    await context.bot.send_message(chat_id=user_id, text="üîî –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ: –ø–æ—Ä–∞ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–∞—Ö–∞—Ä!")

async def smart_remind(update: Update, context: CallbackContext):
    user_id = update.effective_user.id
    if not context.args or context.args[0] not in ['on', 'off']:
        await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /smart_remind on|off")
        return
    if context.args[0] == 'on':
        db.set_reminder_enabled(user_id, 1)
        preferred = smart_reminder.update_preferred_hours_for_user(user_id)
        if preferred:
            await update.message.reply_text(f"‚úÖ –£–º–Ω—ã–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –≤–∫–ª—é—á–µ–Ω—ã. –ß–∞—Å—ã: {preferred}")
        else:
            await update.message.reply_text("‚úÖ –£–º–Ω—ã–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –≤–∫–ª—é—á–µ–Ω—ã (–Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö)")
    else:
        db.set_reminder_enabled(user_id, 0)
        await update.message.reply_text("‚ùå –£–º–Ω—ã–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –æ—Ç–∫–ª—é—á–µ–Ω—ã")

async def remind_status(update: Update, context: CallbackContext):
    user_id = update.effective_user.id
    enabled = db.get_reminder_enabled(user_id)
    pref_json = db.get_preferred_hours(user_id)
    if pref_json:
        import json
        pref = json.loads(pref_json)
        status = "–≤–∫–ª—é—á–µ–Ω—ã" if enabled else "–≤—ã–∫–ª—é—á–µ–Ω—ã"
        await update.message.reply_text(f"üìä –°—Ç–∞—Ç—É—Å —É–º–Ω—ã—Ö –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π: {status}\n–ß–∞—Å—ã: {pref}")
    else:
        await update.message.reply_text("üìä –£–º–Ω—ã–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã")

async def set_reminder_interval(update: Update, context: CallbackContext):
    user_id = update.effective_user.id
    if not context.args:
        current = db.get_reminder_interval(user_id)
        await update.message.reply_text(f"‚è∞ –¢–µ–∫—É—â–∏–π –∏–Ω—Ç–µ—Ä–≤–∞–ª: {current} —á. –£–∫–∞–∂–∏—Ç–µ –Ω–æ–≤–æ–µ —á–∏—Å–ª–æ —á–∞—Å–æ–≤")
        return
    try:
        hours = float(context.args[0])
        if hours <= 0:
            raise ValueError
    except ValueError:
        await update.message.reply_text("‚ùå –£–∫–∞–∂–∏—Ç–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ")
        return
    db.set_reminder_interval(user_id, hours)
    await update.message.reply_text(f"‚úÖ –ò–Ω—Ç–µ—Ä–≤–∞–ª –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {hours} —á")

async def check_missed_reminders(context: CallbackContext):
    import sqlite3
    from datetime import datetime, timedelta
    conn = sqlite3.connect(db.DB_NAME)
    c = conn.cursor()
    c.execute("SELECT user_id, max_hours FROM reminder_intervals")
    users = c.fetchall()
    conn.close()
    for user_id, max_hours in users:
        conn = sqlite3.connect(db.DB_NAME)
        c = conn.cursor()
        c.execute("SELECT timestamp FROM glucose WHERE user_id=? ORDER BY timestamp DESC LIMIT 1", (user_id,))
        row = c.fetchone()
        conn.close()
        if not row:
            continue
        last_time = datetime.fromisoformat(row[0])
        now = datetime.now()
        hours_passed = (now - last_time).total_seconds() / 3600
        if hours_passed > max_hours:
            await context.bot.send_message(chat_id=user_id, text=f"‚ö†Ô∏è –í—ã –Ω–µ –¥–µ–ª–∞–ª–∏ –∑–∞–º–µ—Ä {hours_passed:.1f} —á. –ü–æ—Ä–∞ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–∞—Ö–∞—Ä!")
            db.update_reminder_last_check(user_id)
