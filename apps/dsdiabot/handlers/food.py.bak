from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import CallbackContext
import database as db
import train_food_model
import food_scanner
import os
import logging
import json

logger = logging.getLogger(__name__)

food_model_mode = {}

async def scan_food(update: Update, context: CallbackContext):
    user_id = update.effective_user.id
    mode = food_model_mode.get(user_id, "gemini")
    if mode == "local":
        await scan_food_local(update, context)
    else:
        await scan_food_gemini(update, context)

async def scan_food_gemini(update: Update, context: CallbackContext):
    if not os.getenv('GEMINI_API_KEY'):
        await update.message.reply_text("‚ùå GEMINI_API_KEY –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω")
        return
    if not update.message.photo:
        await update.message.reply_text("üì∏ –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ –µ–¥—ã")
        return
    photo = update.message.photo[-1]
    file = await context.bot.get_file(photo.file_id)
    context.user_data['last_scan_image'] = photo.file_id
    await update.message.reply_text("üîç –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é —Ñ–æ—Ç–æ —á–µ—Ä–µ–∑ Gemini...")
    try:
        image_bytes = await file.download_as_bytearray()
        result = food_scanner.scan_food_image(bytes(image_bytes))
        if not result:
            await update.message.reply_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –µ–¥—É")
            return
        context.user_data['last_scan'] = result
        msg = f"üçΩÔ∏è **{result.get('description', '–ë–ª—é–¥–æ')}**\n\n"
        for food in result.get('foods', []):
            msg += f"‚Ä¢ {food['name']}: ~{food['weight_g']}–≥ = {food['total_carbs']}–≥ —É–≥–ª.\n"
        msg += f"\nüìä **–í—Å–µ–≥–æ —É–≥–ª–µ–≤–æ–¥–æ–≤:** {result['total_carbs']}–≥"
        msg += f"\nüçû **–•–ï:** {result['total_xe']}"
        keyboard = [
            [InlineKeyboardButton("‚úÖ –í–µ—Ä–Ω–æ, –∑–∞–ø–∏—Å–∞—Ç—å", callback_data="confirm_scan"),
             InlineKeyboardButton("‚úèÔ∏è –ò—Å–ø—Ä–∞–≤–∏—Ç—å", callback_data="edit_scan")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(msg, parse_mode='Markdown', reply_markup=reply_markup)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è Gemini: {e}")
        await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–æ—Ç–æ")

async def scan_food_local(update: Update, context: CallbackContext):
    if not update.message.photo:
        await update.message.reply_text("üì∏ –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ –µ–¥—ã")
        return
    photo = update.message.photo[-1]
    file = await context.bot.get_file(photo.file_id)
    await update.message.reply_text("üîç –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é —Ñ–æ—Ç–æ –ª–æ–∫–∞–ª—å–Ω–æ–π –º–æ–¥–µ–ª—å—é...")
    try:
        image_bytes = await file.download_as_bytearray()
        pred_xe, error = train_food_model.predict_xe(bytes(image_bytes))
        if error:
            await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞: {error}")
            return
        user_id = update.effective_user.id
        settings = db.get_user_settings(user_id)
        msg = f"üçΩÔ∏è **–ê–Ω–∞–ª–∏–∑ –±–ª—é–¥–∞ (–ª–æ–∫–∞–ª—å–Ω–∞—è –º–æ–¥–µ–ª—å)**\nüìä **–•–ï:** {pred_xe:.1f}"
        if settings:
            sensitivity, insulin_to_carb, target = settings
            dose = pred_xe * insulin_to_carb
            msg += f"\nüíâ **–ò–Ω—Å—É–ª–∏–Ω:** {dose:.2f} –µ–¥"
            keyboard = [[InlineKeyboardButton("‚úÖ –ó–∞–ø–∏—Å–∞—Ç—å", callback_data=f"log_meal_{pred_xe:.1f}")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await update.message.reply_text(msg, reply_markup=reply_markup)
        else:
            await update.message.reply_text(msg)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è: {e}")
        await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–æ—Ç–æ")

async def scan_callback(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()
    data = query.data
    user_id = query.from_user.id
    if data == "confirm_scan":
        result = context.user_data.get('last_scan')
        if not result:
            await query.edit_message_text("‚ùå –î–∞–Ω–Ω—ã–µ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")
            return
        db.add_meal(user_id, result['total_xe'])
        if 'last_scan_image' in context.user_data:
            db.save_training_data(user_id, context.user_data['last_scan_image'], json.dumps(result), result['total_xe'])
        await query.edit_message_text(f"‚úÖ –ó–∞–ø–∏—Å–∞–Ω–æ: {result['total_xe']} –•–ï")
    elif data == "edit_scan":
        await query.edit_message_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –•–ï (—á–∏—Å–ª–æ)")
        context.user_data['awaiting_manual_xe'] = True
    elif data.startswith("log_meal_"):
        xe = float(data.replace("log_meal_", ""))
        db.add_meal(user_id, xe)
        await query.edit_message_text(f"‚úÖ –ó–∞–ø–∏—Å–∞–Ω–æ: {xe} –•–ï")

async def train_food(update: Update, context: CallbackContext):
    user_id = update.effective_user.id
    admin_id = int(os.getenv('ADMIN_ID', 0))
    if user_id != admin_id:
        await update.message.reply_text("‚ùå –¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä")
        return
    await update.message.reply_text("üß† –ù–∞—á–∏–Ω–∞—é –æ–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏ –µ–¥—ã...")
    import threading
    def train_and_notify():
        token = os.getenv("TELEGRAM_TOKEN")
        result = train_food_model.train_model(token)
        app = context.application
        if "error" in result:
            app.create_task(update.message.reply_text(f"‚ùå {result['error']}"))
        else:
            app.create_task(update.message.reply_text(f"‚úÖ –ú–æ–¥–µ–ª—å –æ–±—É—á–µ–Ω–∞! MAE: {result['val_mae']:.3f} –•–ï"))
    threading.Thread(target=train_and_notify).start()

async def food_model_status(update: Update, context: CallbackContext):
    path = train_food_model.get_latest_model_path()
    if path:
        await update.message.reply_text(f"‚úÖ –õ–æ–∫–∞–ª—å–Ω–∞—è –º–æ–¥–µ–ª—å: {os.path.basename(path)}")
    else:
        await update.message.reply_text("‚ùå –õ–æ–∫–∞–ª—å–Ω–∞—è –º–æ–¥–µ–ª—å –Ω–µ –æ–±—É—á–µ–Ω–∞")

async def food_model_switch(update: Update, context: CallbackContext):
    user_id = update.effective_user.id
    if not context.args or context.args[0] not in ['gemini', 'local']:
        await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /food_model_switch gemini|local")
        return
    if context.args[0] == 'local' and not train_food_model.get_latest_model_path():
        await update.message.reply_text("‚ùå –õ–æ–∫–∞–ª—å–Ω–∞—è –º–æ–¥–µ–ª—å –Ω–µ –æ–±—É—á–µ–Ω–∞")
        return
    food_model_mode[user_id] = context.args[0]
    await update.message.reply_text(f"‚úÖ –†–µ–∂–∏–º: {context.args[0]}")
