"""
–ì–µ–Ω–µ—Ä–∞—Ü–∏—è Rekordbox XML —Å –ø–ª–µ–π–ª–∏—Å—Ç–∞–º–∏ –ø–æ –∂–∞–Ω—Ä–∞–º
–ó–≤—ë–∑–¥–æ—á–∫–∏ –æ—Ç—Ä–∞–∂–∞—é—Ç —ç–Ω–µ—Ä–≥–∏—é/–Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ
"""

import xml.etree.ElementTree as ET
from xml.dom import minidom
from typing import List, Dict
import os
from datetime import datetime


class RekordboxXMLGenerator:
    """–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä Rekordbox XML"""
    
    def __init__(self):
        self.root = ET.Element('DJ_PLAYLISTS', Version="1.0.0")
        self.product = ET.SubElement(self.root, 'PRODUCT', Name="rekordbox", Version="6.0.0", Company="Pioneer DJ")
        self.collection = ET.SubElement(self.root, 'COLLECTION', Entries="0")
        self.playlists = ET.SubElement(self.root, 'PLAYLISTS')
        
        self.root_node = ET.SubElement(
            self.playlists, 
            'NODE', 
            Type="0", 
            Name="ROOT", 
            Count="0"
        )
        
        self.track_id_counter = 1
        self.tracks_added = {}
    
    def add_track(self, track_data: Dict) -> int:
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç—Ä–µ–∫–∞ –≤ –∫–æ–ª–ª–µ–∫—Ü–∏—é"""
        file_path = track_data['file_path']
        if file_path in self.tracks_added:
            return self.tracks_added[file_path]
        
        track_id = self.track_id_counter
        self.track_id_counter += 1
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∂–∞–Ω—Ä (–Ω–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è) –¥–ª—è –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö
        genre = track_data.get('genre', track_data.get('existing_genre', 'Unknown'))
        
        track_attribs = {
            'TrackID': str(track_id),
            'Name': track_data.get('title', track_data['filename']),
            'Artist': track_data.get('artist', 'Unknown'),
            'Album': track_data.get('album', ''),
            'Genre': genre,  # –ñ–∞–Ω—Ä –º—É–∑—ã–∫–∏
            'Kind': self._get_file_kind(file_path),
            'Size': str(os.path.getsize(file_path)) if os.path.exists(file_path) else '0',
            'TotalTime': str(int(track_data['duration'])),
            'Year': track_data.get('year', ''),
            'AverageBpm': f"{track_data['bpm']:.2f}",
            'DateAdded': datetime.now().strftime('%Y-%m-%d'),
            'BitRate': '320',
            'SampleRate': '44100',
            'Comments': f"Mood: {track_data.get('mood', '')}",  # –ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ –≤ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è—Ö
            'Rating': str(track_data.get('energy_stars', 3)),  # –ó–≤—ë–∑–¥–æ—á–∫–∏ = —ç–Ω–µ—Ä–≥–∏—è
            'Location': f"file://localhost{file_path}",
            'Remixer': '',
            'Tonality': track_data.get('camelot', ''),
            'Label': '',
            'Mix': ''
        }
        
        track_elem = ET.SubElement(self.collection, 'TRACK', **track_attribs)
        
        # Beatgrid
        self._add_tempo(track_elem, track_data)
        
        # Cue-—Ç–æ—á–∫–∏
        self._add_position_marks(track_elem, track_data)
        
        self.tracks_added[file_path] = track_id
        self.collection.set('Entries', str(len(self.tracks_added)))
        
        return track_id
    
    def _get_file_kind(self, file_path: str) -> str:
        """–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ —Ñ–∞–π–ª–∞"""
        ext = os.path.splitext(file_path)[1].lower()
        kinds = {
            '.mp3': 'MP3 File',
            '.flac': 'FLAC File',
            '.wav': 'WAV File',
            '.aiff': 'AIFF File',
            '.m4a': 'AAC File',
            '.aac': 'AAC File'
        }
        return kinds.get(ext, 'Audio File')
    
    def _add_tempo(self, track_elem: ET.Element, track_data: Dict):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ beatgrid"""
        bpm = track_data['bpm']
        
        tempo_attribs = {
            'Inizio': '0.000',
            'Bpm': f"{bpm:.2f}",
            'Metro': '4/4',
            'Battito': '1'
        }
        
        ET.SubElement(track_elem, 'TEMPO', **tempo_attribs)
    
    def _add_position_marks(self, track_elem: ET.Element, track_data: Dict):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ cue-—Ç–æ—á–µ–∫"""
        # Memory Cue
        ET.SubElement(track_elem, 'POSITION_MARK', {
            'Name': '',
            'Type': '0',
            'Start': '0.000',
            'Num': '-1'
        })
        
        # Hot Cue A - Intro
        ET.SubElement(track_elem, 'POSITION_MARK', {
            'Name': 'Intro',
            'Type': '0',
            'Start': f"{track_data['cue_intro']:.3f}",
            'Num': '0',
            'Red': '40',
            'Green': '226',
            'Blue': '20'
        })
        
        # Hot Cue B - Build-up
        ET.SubElement(track_elem, 'POSITION_MARK', {
            'Name': 'Build',
            'Type': '0',
            'Start': f"{track_data['cue_buildup']:.3f}",
            'Num': '1',
            'Red': '233',
            'Green': '237',
            'Blue': '26'
        })
        
        # Hot Cue C - Drop
        ET.SubElement(track_elem, 'POSITION_MARK', {
            'Name': 'Drop',
            'Type': '0',
            'Start': f"{track_data['cue_drop']:.3f}",
            'Num': '2',
            'Red': '242',
            'Green': '22',
            'Blue': '45'
        })
        
        # Hot Cue D - Outro
        ET.SubElement(track_elem, 'POSITION_MARK', {
            'Name': 'Outro',
            'Type': '0',
            'Start': f"{track_data['cue_outro']:.3f}",
            'Num': '3',
            'Red': '23',
            'Green': '147',
            'Blue': '226'
        })
        
        # Loop
        loop_length = (60 / track_data['bpm']) * 16 if track_data['bpm'] > 0 else 8
        if track_data['loop_start'] + loop_length <= track_data['duration']:
            ET.SubElement(track_elem, 'POSITION_MARK', {
                'Name': 'Loop Out',
                'Type': '4',
                'Start': f"{track_data['loop_start']:.3f}",
                'End': f"{min(track_data['loop_start'] + loop_length, track_data['duration']):.3f}",
                'Num': '-1'
            })
    
    def create_playlist(self, name: str, track_ids: List[int], parent_node=None):
        """–°–æ–∑–¥–∞–Ω–∏–µ –ø–ª–µ–π–ª–∏—Å—Ç–∞"""
        if parent_node is None:
            parent_node = self.root_node
        
        playlist_node = ET.SubElement(
            parent_node,
            'NODE',
            Name=name,
            Type="1",
            KeyType="0",
            Entries=str(len(track_ids))
        )
        
        for track_id in track_ids:
            ET.SubElement(playlist_node, 'TRACK', Key=str(track_id))
        
        current_count = int(parent_node.get('Count', '0'))
        parent_node.set('Count', str(current_count + 1))
    
    def create_folder(self, name: str, parent_node=None) -> ET.Element:
        """–°–æ–∑–¥–∞–Ω–∏–µ –ø–∞–ø–∫–∏"""
        if parent_node is None:
            parent_node = self.root_node
        
        folder_node = ET.SubElement(
            parent_node,
            'NODE',
            Name=name,
            Type="0",
            Count="0"
        )
        
        current_count = int(parent_node.get('Count', '0'))
        parent_node.set('Count', str(current_count + 1))
        
        return folder_node
    
    def save(self, output_path: str):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ XML"""
        xml_str = minidom.parseString(ET.tostring(self.root)).toprettyxml(indent="  ")
        xml_lines = [line for line in xml_str.split('\n') if line.strip()]
        xml_str = '\n'.join(xml_lines)
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(xml_str)
        
        print(f"‚úì Rekordbox XML —Å–æ—Ö—Ä–∞–Ω—ë–Ω: {output_path}")


def create_rekordbox_xml(tracks_data: List[Dict], output_path: str) -> None:
    """
    –°–æ–∑–¥–∞–Ω–∏–µ Rekordbox XML —Å –ø–ª–µ–π–ª–∏—Å—Ç–∞–º–∏ –ø–æ –∂–∞–Ω—Ä–∞–º
    
    Args:
        tracks_data: —Å–ø–∏—Å–æ–∫ —Ç—Ä–µ–∫–æ–≤
        output_path: –ø—É—Ç—å –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
    """
    generator = RekordboxXMLGenerator()
    
    track_ids = []
    genre_tracks = {}
    
    print(f"\n–î–æ–±–∞–≤–ª–µ–Ω–∏–µ {len(tracks_data)} —Ç—Ä–µ–∫–æ–≤ –≤ XML...")
    
    for track_data in tracks_data:
        track_id = generator.add_track(track_data)
        track_ids.append(track_id)
        
        # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ –∂–∞–Ω—Ä–∞–º
        genre = track_data.get('genre', 'Unknown')
        if genre not in genre_tracks:
            genre_tracks[genre] = []
        genre_tracks[genre].append(track_id)
    
    # –°–æ–∑–¥–∞—ë–º –ø–ª–µ–π–ª–∏—Å—Ç—ã –ø–æ –∂–∞–Ω—Ä–∞–º
    if genre_tracks:
        genre_folder = generator.create_folder("üéµ By Genre")
        
        for genre, cat_track_ids in sorted(genre_tracks.items()):
            if cat_track_ids:
                generator.create_playlist(genre, cat_track_ids, genre_folder)
                print(f"  ‚úì –ü–ª–µ–π–ª–∏—Å—Ç '{genre}': {len(cat_track_ids)} —Ç—Ä–µ–∫–æ–≤")
    
    generator.save(output_path)
