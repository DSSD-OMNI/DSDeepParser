from core.base import DataSource
from core.fetcher import HttpFetcher
from core.parser import JsonParser
from core.transformer import Transformer
from storage.sqlite_storage import SQLiteStorage
from storage.file_storage import FileStorage
from core.storage import MultiStorage
import logging

logger = logging.getLogger(__name__)

class FPLSource(DataSource):
    def __init__(self, config: dict, global_config: dict, rate_limiter, session_pool):
        super().__init__(config, global_config)
        self.fetcher = HttpFetcher(
            config["fetcher"],
            rate_limiter,
            session_pool,
            global_config["network"]["proxies"],
            global_config["network"]["user_agents"],
            cache_dir=global_config["network"].get("cache_dir", "./cache"),
            global_config=global_config,
            source_name=self.name
        )
        self.parser = JsonParser(config["parser"])
        self.transformer = Transformer(config.get("transformer", []))

        storage_configs = config.get("storage")
        if not isinstance(storage_configs, list):
            storage_configs = [storage_configs]

        self.storage_items = []
        for st_cfg in storage_configs:
            if st_cfg is None:
                continue
            if st_cfg["type"] == "sqlite":
                storage = SQLiteStorage(global_config["default_storage"]["path"])
                self.storage_items.append((storage, st_cfg))
            elif st_cfg["type"] == "file":
                storage = FileStorage(global_config["export"]["csv_dir"])
                self.storage_items.append((storage, st_cfg))

    async def fetch(self):
        params = self.config["fetcher"].get("params", {})
        logger.info(f"Источник {self.name}: выполняем запрос с параметрами {params}")
        return await self.fetcher.fetch(params)

    async def parse(self, raw_data):
        logger.info(f"Источник {self.name}: парсим данные")
        return self.parser.parse(raw_data)

    async def transform(self, records):
        logger.info(f"Источник {self.name}: применяем трансформации к {len(records)} записям")
        return self.transformer.transform(records)

    async def store(self, records):
        logger.info(f"Источник {self.name}: сохраняем {len(records)} записей в {len(self.storage_items)} хранилищ(ах)")
        for storage, st_cfg in self.storage_items:
            await storage.store(records, st_cfg)

async def fetch_manager_history(manager_id: int) -> List[Dict]:
    """Получить историю менеджера (entry/{id}/history/)"""
    url = f"https://fantasy.premierleague.com/api/entry/{manager_id}/history/"
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            if resp.status == 200:
                data = await resp.json()
                return data.get('current', [])
    return []

async def fetch_manager_picks(manager_id: int, event: int) -> List[Dict]:
    """Получить состав менеджера на игровую неделю"""
    url = f"https://fantasy.premierleague.com/api/entry/{manager_id}/event/{event}/picks/"
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            if resp.status == 200:
                data = await resp.json()
                return data.get('picks', [])
    return []

async def fetch_manager_transfers(manager_id: int) -> List[Dict]:
    """Получить трансферы менеджера"""
    url = f"https://fantasy.premierleague.com/api/entry/{manager_id}/transfers/"
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            if resp.status == 200:
                return await resp.json()
    return []

async def get_league_managers(league_id: int) -> List[int]:
    """Получает список entry_id менеджеров из классической лиги."""
    from app.fetchers.fpl_api import get_league_standings
    standings = await get_league_standings(league_id)
    return [entry['entry'] for entry in standings]

async def run_full_update(league_id: int = None):
    """Запускает полный сбор данных для всех менеджеров указанной лиги."""
    import os
    if league_id is None:
        league_id = int(os.getenv('LEAGUE_ID', '0'))
        if league_id == 0:
            raise ValueError("LEAGUE_ID не задан")
    from app.core.database import AsyncSessionLocal
    async with AsyncSessionLocal() as db:
        # 1. Bootstrap и Fixtures
        async with aiohttp.ClientSession() as session:
            await fetch_bootstrap(session, db)
            await asyncio.sleep(REQUEST_DELAY)
            await fetch_fixtures(session, db)
            await asyncio.sleep(REQUEST_DELAY)

        # 2. Получаем список менеджеров
        entry_ids = await get_league_managers(league_id)
        logger.info(f"Найдено менеджеров: {len(entry_ids)}")

        # 3. Для каждого менеджера собираем историю, трансферы и picks
        for eid in entry_ids:
            async with aiohttp.ClientSession() as session:
                await fetch_manager_history(session, db, eid)
                await asyncio.sleep(REQUEST_DELAY)
                await fetch_manager_transfers(session, db, eid)
                await asyncio.sleep(REQUEST_DELAY)
                # Определяем текущий GW из bootstrap (можно передать)
                # Для упрощения собираем picks для последних 5 GW
                current_gw = 27  # замените на автоматическое определение
                for gw in range(max(1, current_gw-5), current_gw+1):
                    await fetch_manager_picks(session, db, eid, gw)
                    await asyncio.sleep(REQUEST_DELAY * 0.5)
